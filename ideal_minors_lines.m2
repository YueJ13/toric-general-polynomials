-- Part1: analyse ideals generated by minors of A 

-- generate the ring "Rl" of {x_1...x_n, c_{\alpha_1 ... \alpha_n}, g_11...g_nn}, where \sum\alpha_i = d
-- Input: number of variables "n" and degree of monomials "d"
-- Output: ring "Rl"
generateRing = method()
generateRing(ZZ, ZZ) := (n, d) ->  (
    -- c_\alpha
    params = apply(compositions(n, d), i -> (value("c" | concatenate(apply(i, j -> toString j)))));
    -- g_ij
    g = apply(toList(1..n) ** toList(1..n), i -> "g" | toString i#0 | toString i#1);
    -- generate the ring 
    Rl := QQ[x_1..x_n, params, g];
    return Rl
    )

-- generate the generic polynomial "f" with n variables and d degree
-- Input: number of variables "n" and degree of monomials "d"
-- Output: polynomial "f"
generateFunction = method()
generateFunction(ZZ, ZZ, Ring) := (n, d, Rl) -> (
    -- generate all monomials with degree d in the ring Rx -- "monomialsList"
    Rx := QQ[x_1..x_n];
    monomialsList = flatten entries basis(d, Rx);
    -- generate the generic polynomial f -- "f"
    f := sum(toList(0..(length(compositions(n, d))-1)) / (i -> Rl_(i+n) * sub(monomialsList#i, Rl)));
    return f 
    )

-- generate the matrix A such that A*g = \vec{g *action f} with entries in c_\alpha
-- Input: number of variables "n", degree of monomials "d" and ring "Rl" = generateRing(n, d)
-- Output: matrix "A"
generateMatrix = method()
generateMatrix(ZZ, ZZ, Ring) := (n, d, Rl) -> (
    -- generate polynomial g*f -- "gstarf"
    Rx := QQ[x_1..x_n];
    monomialsList = flatten entries basis(d, Rx);
    fterms = toList(0..(length(compositions(n, d))-1)) / (i -> Rl_(i+n) * sub(monomialsList#i, Rl));
    ftermsexp = apply(monomialsList, exponents);
    gstarf = sub(sum(0..(length(fterms)-1), j -> (sum(1..n, i -> (innerSum = sum(1..n, k -> Rl_((i-1)*n+k-1+n+length(compositions(n, d))) * Rl_(k-1)); sub(ftermsexp#j#0#(i-1), Rl) * (sub(1,Rl)/Rl_(i-1)) * fterms#j * innerSum)))), Rl);
    -- get the coefficients for monomials x_\alpha in g*f -- "vecgstarf"
    (monomialsx, vecgstarf) = coefficients(gstarf,  Variables => toList(0..(n-1)) / (i -> Rl_i));
    -- get matrix A -- "MatrixA"
    (gij, MatrixA) = coefficients(matrix{flatten entries vecgstarf},  Variables => toList((n+length(compositions(n, d)))..(n+length(compositions(n, d))-1+n^2)) / (i -> Rl_i));
    return MatrixA
    )

-- generate the ideal <r*r minors of A> and calculate the dimension and degree
-- Input: number of variables "n", degree of monomials "d", order of minors "r" and matrix A "MatrixA" = generateMatrix(n, d, Rl)
-- Output: ideal <r*r minors of A> "I1", dimension of the ideal and degree of the ideal 
generateMinors = method()
generateMinors(ZZ, ZZ, ZZ, Matrix) := (n, d, r, MatrixA) -> (
    -- ring of c_\alpha -- "Rc"
    Rc := QQ[apply(compositions(n, d), i -> (value("c" | concatenate(apply(i, j -> toString j)))))];
    -- ideal generated by all r minors of MatrixA and transfer to ring Rc -- "I1"
    I1 = sub(minors(r, MatrixA), Rc);
    return (I1, dim I1, degree I1)
    )

-- Example for n=2, d=4 and r=4
-- ring 
Rl = generateRing(2, 4) 
-- polynomial
f = generateFunction(2, 4, Rl)
-- matrix
A = generateMatrix(2, 4, Rl)
-- minors
(I4, dim4, degree4) = generateMinors(2, 4, 4, A)

-- Part2: analyse ideals generated under the condition of certain number of lines

-- generate the elimination ideal of 2 lines with multiplicity d1 and d2 and 1 lines with d1=0 and d2=d
-- Input: number of variables "n", degree of monomials "d", multiplicity of the first line "d1" and multiplicity of the second line "d2"
-- Output: elimination ideal in the ring of c_\alpha "eliminationideal", dimension of the ideal and degree of the ideal
generateIdeallines = method()
generateIdeallines(ZZ, ZZ, ZZ, ZZ) := (n, d, d1, d2) -> (
    -- parameters c_\alpha
    params = apply(compositions(n, d), i -> (value("c" | concatenate(apply(i, j -> toString j)))));
    -- parameters w_i
    lineparams = apply(toList(1..4), i -> "w" | toString i);
    -- ring of {x_1..x_n, c_\alpha and w_1..w_4}
    Rw := QQ[x_1..x_n, params, lineparams];
    -- write f with parameters w_i
    fw = (Rw_(2+length(params))*Rw_0-Rw_(2+length(params)+1)*Rw_1)^d1*(Rw_(2+length(params)+2)*Rw_0-Rw_(2+length(params)+3)*Rw_1)^d2;
    -- get coefficients for monomials in Rw -- "coeffline"
    (monoline,coeffline) = coefficients(fw,  Variables => toList(0..(n-1)) / (i -> Rw_i));
    -- get the ideal generated by the polynomilas c_\alpha - coefficient of x_\alpha in Rw -- "idealline"
    coefflinelist = flatten entries coeffline;
    idealline = ideal(toList(0..(length(coefflinelist)-1)) / (i -> (Rw_(i+n)-coefflinelist#i)));
    -- get the elimination ideal in Rc (the ring of c_\alpha) -- "eliminationideal"
    Rc := QQ[params];
    eliminationideal = sub((eliminate((toList(0..(length(lineparams)-1)) / (i -> Rw_(i+n+length(params)))), idealline)), Rc);  
    (eliminationideal, dim eliminationideal, degree eliminationideal)
)

-- Example for n=2, d=4, 2 lines with multiplicity (1, 3) and (2, 2)
(I13, dim13, degree13) = generateIdeallines(2, 4, 1, 3)
(I22, dim22, degree22) = generateIdeallines(2, 4, 2, 2)